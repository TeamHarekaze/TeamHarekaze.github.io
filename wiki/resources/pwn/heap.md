# アルゴリズム系(memory allocator)

いわゆるHeap問と呼ばれる問題で使われる攻撃手法です。

動的なメモリ管理ではHeap領域と呼ばれる必要に応じて確保される領域にデータを詰め込んでいく手法を取ります。確保された領域のことをここではチャンクと呼びます。

より効率よくメモリを管理するためのアルゴリズムが組まれていて、こういったアルゴリズムを `memory allocator` と呼びます。

 `memory allocator` をプログラムの作成者がうまく使えなかったために不具合が生じることがあります。

そういった不具合を使った攻撃手法をアルゴリズム系(memory allocator)の攻撃手法として以下に紹介します。

またここで使われる `memory allocator` は `glibc malloc` を用いたものであることを前提とします。

##  main\_arena のアドレスのリーク 

```main_arena``` は `libc` 上に配置される構造体であるため、そのアドレスをリークすることで `lbc` のアドレスのリークが可能になります。

また ```main_arena``` は `unsoreted bin` サイズの領域の解放のときに ```main_arena``` の構造体上の変数のアドレスが現れるなどします。

そのため、もし終端文字の埋め忘れなどがあれば再度同じ領域を確保するなどすることで ```main_arena``` のリークが出来ます。

### 基礎となる攻撃

-  終端文字列の埋め忘れによるメモリの値のリーク 

### 応用した攻撃

-  `libc` の先頭アドレスのリーク 

- ```__IO_list_all``` 書き換え後、 不正な `unsorted bins Attack`による `abort()` 呼び出し

##  heap 領域のアドレスのリーク 

こちらも ```main_arena``` と同様に `fast bin` サイズの領域の開放時などに現れるためリークが可能です。

### 基礎となる攻撃

-  終端文字列の埋め忘れによるメモリの値のリーク 

### 応用した攻撃

- いろいろつかえる

##  ヒープ領域のBoF 

ヒープ領域に確保したメモリで起きるBoFを起因とした攻撃です。

ヒープ領域においたデータを改竄するものから、ヒープ領域のデータ構造そのものを改竄することでアルゴリズム系(memory allocator)の攻撃につなげることもできます。

### 基礎となる攻撃

-   ユーザーからの入力によるBoF 

-  入力の終端埋めにおけるBoF（Off By One) 

-  コピー系の関数を使ったBoF 

### 応用した攻撃

-  チャンクサイズの書き換え  

-  topチャンクの書き換えによる任意アドレスへの動的メモリの割当 

##  malloc() で発動する攻撃 

`malloc()` はサイズ値ひとつを引数に取ります。このサイズ値によって条件次第で攻撃者の意図した動作を起こす攻撃が出来ます。

### 基礎となる攻撃

とくになし

### 応用した攻撃

-  topチャンクの書き換えによる任意アドレスへの動的メモリの割当 

##  free() で発動する攻撃 

`free()` はアドレス値ひとつを引数に取ります。しかし、このアドレス値には `malloc()` や `strdup()` などの `malloc()` 系関数の戻り値によるアドレス以外もとることができます。

これを利用することで偽のメモリ領域の解放をしたり、すでに解放済みのメモリ領域をもう一度解放したりする攻撃ができます。

### 基礎となる攻撃

とくになし

### 応用した攻撃

-  fastbinの二重解放 

##  fastbinの二重解放 

直接 ```main_arena``` につながっている`fast bin`は二重解放しようとするとabortして落ちてしまいます。しかし、`main_arena`に間接的につながっている `fast bin` は二重解放してもabortしません。

これを利用することで、解放後チャンクへ書き込みを行うことが出来るようになります。

### 基礎となる攻撃

-  `free()` で発動する攻撃 

### 応用した攻撃

-  解放後チャンクの書き換え 

##  解放後チャンクの書き換え 

通称 `use after free`

解放後のチャンクには `malloc()` あるいは `free()` をした際にアルゴリズムで定められたデータの構造となるように記録されている情報が置いてあります。

この情報を書き換えることで、攻撃者の意図するデータの構造を作り出す攻撃が可能となります。

### 基礎となる攻撃

-  ヒープ領域のBoF 

-  fastbinの二重解放 

### 応用した攻撃

-  fastbinを任意のアドレスにつなげる 

##  fastbinを任意のアドレスにつなげる 

fastbinのfdを書き換えることで、任意アドレスにfastbinの割り当てられるリンクを貼る攻撃が出来ます。

ただし、fdの直前（`x86`では1ワード前のワード、 `amd64`では1ダブルワード前のダブルワード)が対応するfastbinのサイズになるようにしなければなりません。

### 基礎となる攻撃

-  解放後チャンクの書き換え 

-  `malloc()` で発動する攻撃 

### 応用した攻撃

-  0x70サイズのfastbinのリンクによる```__{malloc|realloc|memalign}_hook``` に関数の登録（64bit限定） 

##  0x70サイズのfastbinのリンクによる\_\_{malloc|realloc|memalign}\_hook への関数の登録 

### 基礎となる攻撃

-  hookやvtable登録による任意アドレスの呼び出し 

### 応用した攻撃

-  one gadgetによるシェルの起動 

##  unsortedbin、smallbinの任意アドレスへのリンク 

fd bk を調整することで、任意アドレスへbinを割り当てることが出来る。

満たさなければならない条件は 

- chunkのfd = 任意アドレス として 任意アドレスのbk == chunkのfd

- chunkのbk = 任意アドレス として 任意アドレスのfd == chunkのbk

の両方

##  偽のunsortedbinの統合によるbinと割当領域の重なり 

unsortedbin は

- chunkのfd = 任意アドレス として 任意アドレスのbk == chunkのfd

- chunkのbk = 任意アドレス として 任意アドレスのfd == chunkのbk

- 次の割当領域の ```prev_size``` == チャンクのsize

を満たしていれば、その後にある領域を開放することでいま開放された領域と統合される。

##  topチャンクの改竄によるsysmalloc()の発動 

topチャンクのサイズをいい感じに改竄して、そのサイズ以上のmalloc()をすると大きなunsorted binができる。

##  topチャンクの書き換えによる任意アドレスへの動的メモリの割当 

通称 `House of Force` 

なんかココらへんのバグ

https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#4081

sizeとnbがunsignedではないsize_tだから起こるのかな？

と思ったけど普通にunsigned longだった。

 つまりtopのサイズを0xffffffffffffffff にしておいて、割り当てられる領域のサイズnbを 0x1000000000000000 - (任意のアドレス値）にしておくと 0xffffffffffffffff にしておいて、 0x1000000000000000 - (任意のアドレス値）== - (任意のアドレス値）となり

任意のアドレス値が reminder は top のサイズの入った victim と nb と足し合わされる値になることで

reminder が(任意のアドレス値)になり、それがtopに代入されるという攻撃。

