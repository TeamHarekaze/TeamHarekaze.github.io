# 任意コード・シェルの実行

Pwnの最終目標はシェルを取ることなので、まずはシェルをどう起動したらいいのかについて書いていきます。

##  システムコールの発動 

システムコールを使うことでハードウェアの接点となる場所の機能、つまりOSの根本（カーネル）の機能を呼び出すことができます。

システムコールは `amd64` では、 次のようにレジスターに値をいれて実行します。
          
レジスタ | 入れる値
--------- | ---------
rax | システムコール番号
rdi | 引数1
rsi | 引数2
rdx | 引数3
rcx | 引数4
r8 | 引数5
r9 | 引数6

### 基礎となる攻撃

とくになし

### 応用した攻撃

-  `execve` の発動 

##  execve の発動 

シェルを起動するためにはシステムコールを使い、 `execve("/bin/sh", NULL, NULL)` もしくは `execve("/bin/sh", ["/bin/sh"], NULL)` を実行する必要があります。

`execve("/bin/sh", NULL, NULL)` は `amd64` では以下のようにレジスターに値を入れることで実行できます。

レジスタ | 入れる値
--------- | ---------
rax | 59
rdi | "/bin/sh" へのアドレス値
rsi | 0
rdx | 0

### 基礎となる攻撃

-  システムコールの発動 

### 応用した攻撃

-  `one gadget` によるシェルの起動 

##  vtable 、 hook への任意アドレスの登録  

`vtable` や `hook` へ登録してある関数はプログラム中に `call` 命令で呼び出されることがあります。

よって、 `vtable` や `hook` へ任意アドレスを登録することで意図したコードを実行できる攻撃が出来ます。

### 基礎となる攻撃

とくになし

### 応用した攻撃

-  `one gadget` によるシェルの起動 

##  one gadget によるシェルの起動 

`one gadget` は条件次第でそのアドレスの先頭に命令を飛ばすことで、シェルを起動できるガジェットの一種です。

`one gadget` を  `vtable` 、 `hook` への任意アドレスの登録  などによって、そのアドレスに飛ばすことができればシェルをする攻撃が条件次第で可能となります。

### 基礎となる攻撃

-  `vtable` 、 `hook` への任意アドレスの登録  

### 応用した攻撃

とくになし

##  シェルコードによるシェルの起動 

シェルコードと呼ばれる、 シェルを起動する命令列を実行可能領域に配置し、その先頭のアドレスに飛ばすことでシェルを起動することが出来ます。

### 基礎となる攻撃

-  `execve` の発動 

### 応用した攻撃

-  ROPによるシェルの起動 

##  system() によるシェルの起動 

シェルを起動するための方法として `system()` 関数を使う手段があります。

`system()` はプログラム名を収めたアドレス値を一つとる関数です。プログラム名は環境変数 `PATH` に登録されているディレクトリのプログラムはディレクトリを省略できるため、 `system("/bin/sh")` とも、 `system("sh")` とも呼び出せる可能性があります。

### 基礎となる攻撃

とくになし

### 応用した攻撃

-  `ROP` によるシェルの呼び出し 

-  `.got.plt` 領域への `system()` の登録 

-  `FSOP` によるシェルの起動 

##  FILE\_plus 構造体の vtable 書き換え 

`stdin` や `stdout` 、 `stderr` は ```FILE_plus``` 構造体は `FILE` 構造体に `vtable` を加えた構造体の変数です。

この `vtable` にはいくつかの関数が登録されていて、様々なタイミングで呼びだされます。

これ自体を書き換えたり、あるいは偽の ```FILE_plus``` 構造体を用いることで任意の関数を呼び出す攻撃が可能となります。

### 基礎となる攻撃

-  `vtable`、 `hook` への任意アドレスへの登録 

### 応用した攻撃

-  `abort()` 関数中の ```__IO_flush_all_lockp()``` による攻撃 

##  abort() 関数中の \_\_IO\_flush\_all\_lockp() による攻撃 

**FILE Stream Oriented Programming ( `FSOP` )**

`abort()` 関数中では ```__IO_flush_all_lockp()``` が呼び出されます。この関数は通常は `stdin` 、 `stdout` 、 `stderr` の後処理をする関数ですが、  ```_IO_list_all``` を書き換えたり、 `stderr` などの ```_chain``` を書き換えることで、偽の ```_IO_FILE_plus``` 構造体変数に適用することが出来ます。

これを使うことで、  ```_IO_FILE_plus``` 構造体の `vtable` 書き換え  と同様の効果が期待でき

さらに偽の構造体の ```_chain``` にまた別の偽の構造体を用意することで、さらなる攻撃につなげることも出来ます。

参考

[libioP.h source code [glibc/libio/libioP.h] - Woboq Code Browser](https://code.woboq.org/userspace/glibc/libio/libioP.h.html)

### 基礎となる攻撃

-  ```FILE_plus``` 構造体の `vtable` 書き換え 

### 応用した攻撃

-  `FSOP` を利用したシェルの起動 

##  ret命令を起点とした攻撃 

**Return Oriented Programming(ROP)**

`ret` 命令という呼び出し元の関数に戻る時の命令を起点とした攻撃です。

主に `BoF` によってスタック領域上にある呼び出し元の関数のアドレス以下のメモリ領域を書き換えることでなされる攻撃です。

### ガジェット

この攻撃をするためには複数の命令列を一つの **ガジェット** と呼ばれる単位として考える必要があります。

`ROP` はスタック上に1つ以上のガジェットを置くことでなされる攻撃です。

##### ガジェットの例

- 単純な値

`0xdeadbeef`

ここでは適当な値として `0xdeadbeef` としたが実際には `/bin/sh\x00` などといった有用な値を後述する `pop ガジェット` の後に置くことでレジスタに値を入れるなどできます。

- pop ガジェット

```

0x81fdc pop rax

0x81fdd pop rdx

0x81fde ret

```

この場合は `0x81fdc` といったアドレスをスタック領域に置くことでガジェットとして使えます。

このあとに任意の8バイト（＝64ビット）の値を置いておくことで `rax`、 `rdx` にその値を代入することが出来ます。

- got.plt領域の標準関数

```

0x80a60 jmp qword [0x00a02f58] 

0x80a66 nop 

```

関数は終わりに必ず呼び出し元アドレスに戻るために `ret` 命令があるため、ガジェットとして使うことが出来ます。

（こういった `jmp` 命令を使う攻撃を `ROP` とは区別して `Jump Oriented Programming` という時もあります。）

### 基礎となる攻撃

とくになし

### 応用した攻撃

-  ROPによるシェルの起動 

-  シェルコードによるシェルの起動 

##  FSOP によるシェルの起動 

`FSOP` を利用して `system()` 関数を 偽の ```_IO_FILE_plus``` 構造体 の先頭を"/bin/sh\x00"としたものを引数として呼び出すことでシェルを起動する攻撃が出来ます。

また `system()` 関数を使わずに `one gadget` を使うことによってもシェルの起動が可能となります。

 ###### 基礎となる攻撃

-  `abort()` 関数中の ```__IO_flush_all_lockp()``` による攻撃 

-  `system()` によるシェルの起動 

-  `one gadget` によるシェルの起動 

### 応用した攻撃

とくになし

##  ROPによるシェルの起動 

`ROP` によって、 `system("/bin/sh")` が呼び出されるように `system()` 関数やその引数を準備するガジェットを登録したり、あるいは シェルコードの先頭アドレスを登録することでシェルを起動する攻撃が出来ます。

### 基礎となる攻撃

-  ret命令を起点とした攻撃 

-  `system()` によるシェルの起動 

-  シェルコードによるシェルの起動 

### 応用した攻撃

とくになし

##  .got.plt 領域への system() の登録  


