# Pwn・Exploit攻撃一覧
# 諸注意

以下の説明で出てくる機械語のアーキテクチャは `amd64` (= `x86_64` ) を前提として話をします。

# シェルの起動

Pwnの最終目標はシェルを取ることなので、まずはシェルをどう起動したらいいのかについて書いていきます。

## ☆ システムコールの発動 ☆

システムコールを使うことでハードウェアの接点となる場所の機能、つまりOSの根本（カーネル）の機能を呼び出すことができます。

システムコールは `amd64` では、 次のようにレジスターに値をいれて実行します。
          
レジスタ | 入れる値
--------- | ---------
rax | システムコール番号
rdi | 引数1
rsi | 引数2
rdx | 引数3
rcx | 引数4
r8 | 引数5
r9 | 引数6

### 基礎となる攻撃

とくになし

### 応用した攻撃

- ☆ `execve` の発動 ☆

## ☆ execve の発動 ☆

シェルを起動するためにはシステムコールを使い、 `execve("/bin/sh", NULL, NULL)` もしくは `execve("/bin/sh", ["/bin/sh"], NULL)` を実行する必要があります。

`execve("/bin/sh", NULL, NULL)` は `amd64` では以下のようにレジスターに値を入れることで実行できます。

レジスタ | 入れる値
--------- | ---------
rax | 59
rdi | "/bin/sh" へのアドレス値
rsi | 0
rdx | 0

### 基礎となる攻撃

- ☆ システムコールの発動 ☆

### 応用した攻撃

- ☆ `one gadget` によるシェルの起動 ☆

## ☆ vtable 、 hook への任意アドレスの登録 ☆ 

`vtable` や `hook` へ登録してある関数はプログラム中に `call` 命令で呼び出されることがあります。

よって、 `vtable` や `hook` へ任意アドレスを登録することで意図したコードを実行できる攻撃が出来ます。

### 基礎となる攻撃

とくになし

### 応用した攻撃

- ☆ `one gadget` によるシェルの起動 ☆

## ☆ one gadget によるシェルの起動 ☆

`one gadget` は条件次第でそのアドレスの先頭に命令を飛ばすことで、シェルを起動できるガジェットの一種です。

`one gadget` を ☆ `vtable` 、 `hook` への任意アドレスの登録 ☆ などによって、そのアドレスに飛ばすことができればシェルをする攻撃が条件次第で可能となります。

### 基礎となる攻撃

- ☆ `vtable` 、 `hook` への任意アドレスの登録 ☆ 

### 応用した攻撃

とくになし

## ☆ シェルコードによるシェルの起動 ☆

シェルコードと呼ばれる、 シェルを起動する命令列を実行可能領域に配置し、その先頭のアドレスに飛ばすことでシェルを起動することが出来ます。

### 基礎となる攻撃

- ☆ `execve` の発動 ☆

### 応用した攻撃

- ☆ ROPによるシェルの起動 ☆

## ☆ system() によるシェルの起動 ☆

シェルを起動するための方法として `system()` 関数を使う手段があります。

`system()` はプログラム名を収めたアドレス値を一つとる関数です。プログラム名は環境変数 `PATH` に登録されているディレクトリのプログラムはディレクトリを省略できるため、 `system("/bin/sh")` とも、 `system("sh")` とも呼び出せる可能性があります。

### 基礎となる攻撃

とくになし

### 応用した攻撃

- ☆ `ROP` によるシェルの呼び出し ☆

- ☆ `.got.plt` 領域への `system()` の登録 ☆

- ☆ `FSOP` によるシェルの起動 ☆

## ☆ FILE\_plus 構造体の vtable 書き換え ☆

`stdin` や `stdout` 、 `stderr` は ```FILE_plus``` 構造体は `FILE` 構造体に `vtable` を加えた構造体の変数です。

この `vtable` にはいくつかの関数が登録されていて、様々なタイミングで呼びだされます。

これ自体を書き換えたり、あるいは偽の ```FILE_plus``` 構造体を用いることで任意の関数を呼び出す攻撃が可能となります。

### 基礎となる攻撃

- ☆ `vtable`、 `hook` への任意アドレスへの登録 ☆

### 応用した攻撃

- ☆ `abort()` 関数中の ```__IO_flush_all_lockp()``` による攻撃 ☆

## ☆ abort() 関数中の \_\_IO\_flush\_all\_lockp() による攻撃 ☆

**FILE Stream Oriented Programming ( `FSOP` )**

`abort()` 関数中では ```__IO_flush_all_lockp()``` が呼び出されます。この関数は通常は `stdin` 、 `stdout` 、 `stderr` の後処理をする関数ですが、  ```_IO_list_all``` を書き換えたり、 `stderr` などの ```_chain``` を書き換えることで、偽の ```_IO_FILE_plus``` 構造体変数に適用することが出来ます。

これを使うことで、 ☆ ```_IO_FILE_plus``` 構造体の `vtable` 書き換え ☆ と同様の効果が期待でき

さらに偽の構造体の ```_chain``` にまた別の偽の構造体を用意することで、さらなる攻撃につなげることも出来ます。

参考

[libioP.h source code [glibc/libio/libioP.h] - Woboq Code Browser](https://code.woboq.org/userspace/glibc/libio/libioP.h.html)

### 基礎となる攻撃

- ☆ ```FILE_plus``` 構造体の `vtable` 書き換え ☆

### 応用した攻撃

- ☆ `FSOP` を利用したシェルの起動 ☆

## ☆ ret命令を起点とした攻撃 ☆

**Return Oriented Programming(ROP)**

`ret` 命令という呼び出し元の関数に戻る時の命令を起点とした攻撃です。

主に `BoF` によってスタック領域上にある呼び出し元の関数のアドレス以下のメモリ領域を書き換えることでなされる攻撃です。

### ガジェット

この攻撃をするためには複数の命令列を一つの **ガジェット** と呼ばれる単位として考える必要があります。

`ROP` はスタック上に1つ以上のガジェットを置くことでなされる攻撃です。

##### ガジェットの例

- 単純な値

`0xdeadbeef`

ここでは適当な値として `0xdeadbeef` としたが実際には `/bin/sh\x00` などといった有用な値を後述する `pop ガジェット` の後に置くことでレジスタに値を入れるなどできます。

- pop ガジェット

```

0x81fdc pop rax

0x81fdd pop rdx

0x81fde ret

```

この場合は `0x81fdc` といったアドレスをスタック領域に置くことでガジェットとして使えます。

このあとに任意の8バイト（＝64ビット）の値を置いておくことで `rax`、 `rdx` にその値を代入することが出来ます。

- got.plt領域の標準関数

```

0x80a60 jmp qword [0x00a02f58] 

0x80a66 nop 

```

関数は終わりに必ず呼び出し元アドレスに戻るために `ret` 命令があるため、ガジェットとして使うことが出来ます。

（こういった `jmp` 命令を使う攻撃を `ROP` とは区別して `Jump Oriented Programming` という時もあります。）

### 基礎となる攻撃

とくになし

### 応用した攻撃

- ☆ ROPによるシェルの起動 ☆

- ☆ シェルコードによるシェルの起動 ☆

## ☆ FSOP によるシェルの起動 ☆

`FSOP` を利用して `system()` 関数を 偽の ```_IO_FILE_plus``` 構造体 の先頭を"/bin/sh\x00"としたものを引数として呼び出すことでシェルを起動する攻撃が出来ます。

また `system()` 関数を使わずに `one gadget` を使うことによってもシェルの起動が可能となります。

 ###### 基礎となる攻撃

- ☆ `abort()` 関数中の ```__IO_flush_all_lockp()``` による攻撃 ☆

- ☆ `system()` によるシェルの起動 ☆

- ☆ `one gadget` によるシェルの起動 ☆

### 応用した攻撃

とくになし

## ☆ ROPによるシェルの起動 ☆

`ROP` によって、 `system("/bin/sh")` が呼び出されるように `system()` 関数やその引数を準備するガジェットを登録したり、あるいは シェルコードの先頭アドレスを登録することでシェルを起動する攻撃が出来ます。

### 基礎となる攻撃

- ☆ ret命令を起点とした攻撃 ☆

- ☆ `system()` によるシェルの起動 ☆

- ☆ シェルコードによるシェルの起動 ☆

### 応用した攻撃

とくになし

## ☆ .got.plt 領域への system() の登録 ☆ 



# 入出力による攻撃

入力によっては、 `Buffer Over Flow` 攻撃や出力において終端文字列の埋め忘れによるメモリの値のリークが出来ることがあります。

`Buffer over Flow` 攻撃はプログラムが、確保したメモリのサイズを超えた入力を受け入れる時に出来る攻撃です。 

単純なものではローカル変数の書き換えができます。これを起点とした攻撃手法は他にも色々ありますが、有名な攻撃手法として `Return Oriented Programming` という攻撃があります。

## ☆ 終端文字列の埋め忘れによるメモリの値のリーク ☆

`puts()` 関数や `printf()` 関数は文字列をその文字列の終端文字の一つ前までを出力します。

この性質を使うことで、例えばメモリ配置上ローカル変数hogeの直後にあるローカル変数piyo の値を表示することなどができます。

### 基礎となる攻撃

とくになし

### 応用した攻撃

- ☆ `libc` のアドレスのリーク ☆

- ☆ `heap` 領域のアドレスのリーク ☆

## ☆ libc の先頭アドレスのリーク ☆

メモリの値をリークするときにとくに `libc` が配置されているアドレスをリークすることで、用いている `libc` が判明している状態であれば、 `libc` の先頭アドレスを求めることが出来ます。

リモートのバイナリが `Address Space Layout Randomization(ASLR)` が効いている場合は `libc` の開始位置がランダムに変化してしまうため特定できません。こういったときに `libc` の先頭アドレスをリークすることで、 `libc` 上の関数を呼び出すことが出来ます。

### 基礎となる攻撃

- ☆ 終端文字列の埋め忘れによるメモリの値のリーク ☆
### 応用した攻撃

とくになし

## ☆  ユーザーからの入力によるBoF ☆

単純に入力を受け入れた先のメモリ領域が小さいことに起因する攻撃です。

### 基礎となる攻撃

とくになし

### 応用した攻撃

- ☆ `BoF` による `ROP` ☆

- ☆ ヒープ領域のBoF ☆

## ☆ 入力の終端埋めにおけるBoF（Off By One) ☆

入力を受け入れた先のメモリ領域は正しいが、その直後にNULL文字('\x00')などを埋め込むといったプログラムの動作によって起きうる攻撃です。

これによってアドレスの書き換え先が代わるなどすると攻撃者の意図した動作を組み込める可能性があります。

### 基礎となる攻撃

とくになし

### 応用した攻撃

- ☆ ヒープ領域のBoF ☆

## ☆ コピー系の関数を使ったBoF ☆

メモリ上のデータを他のメモリ上の領域にコピーするときにコピー先のメモリ領域のサイズがコピー元より小さい時に出来る攻撃です。

こちらは `BoF by User Input` のときと同様の攻撃ができます。

### 基礎となる攻撃

とくになし

### 応用した攻撃

- ☆ `BoF` による `ROP` ☆

- ☆ ヒープ領域のBoF ☆

## ☆ BoF による ROP ☆

スタック領域のローカル変数のメモリで起こる `BoF` を使うと `ROP` 攻撃が可能になります。

ただし、 バイナリの `Stack Smashed Protector(SSP)` が有効である場合は、スタック上の `canary` を決められた値にしなければいけません。このときに `canary` をリークすることで、決められた値をスタック上に置くという手段が存在します。

### 基礎となる攻撃

- ☆ ret命令を起点とした攻撃 ☆

- ☆  ユーザーからの入力によるBoF ☆

- ☆ コピー系の関数を使ったBoF ☆

### 応用した攻撃

- ☆ ROPによるシェルの起動 ☆

# アルゴリズム系(memory allocator)

いわゆるHeap問と呼ばれる問題で使われる攻撃手法です。

動的なメモリ管理ではHeap領域と呼ばれる必要に応じて確保される領域にデータを詰め込んでいく手法を取ります。確保された領域のことをここではチャンクと呼びます。

より効率よくメモリを管理するためのアルゴリズムが組まれていて、こういったアルゴリズムを `memory allocator` と呼びます。

 `memory allocator` をプログラムの作成者がうまく使えなかったために不具合が生じることがあります。

そういった不具合を使った攻撃手法をアルゴリズム系(memory allocator)の攻撃手法として以下に紹介します。

またここで使われる `memory allocator` は `glibc malloc` を用いたものであることを前提とします。

## ☆ main\_arena のアドレスのリーク ☆

```main_arena``` は `libc` 上に配置される構造体であるため、そのアドレスをリークすることで `lbc` のアドレスのリークが可能になります。

また ```main_arena``` は `unsoreted bin` サイズの領域の解放のときに ```main_arena``` の構造体上の変数のアドレスが現れるなどします。

そのため、もし終端文字の埋め忘れなどがあれば再度同じ領域を確保するなどすることで ```main_arena``` のリークが出来ます。

### 基礎となる攻撃

- ☆ 終端文字列の埋め忘れによるメモリの値のリーク ☆

### 応用した攻撃

- ☆ `libc` の先頭アドレスのリーク ☆

- ```__IO_list_all``` 書き換え後、 不正な `unsorted bins Attack`による `abort()` 呼び出し

## ☆ heap 領域のアドレスのリーク ☆

こちらも ```main_arena``` と同様に `fast bin` サイズの領域の開放時などに現れるためリークが可能です。

### 基礎となる攻撃

- ☆ 終端文字列の埋め忘れによるメモリの値のリーク ☆

### 応用した攻撃

- いろいろつかえる

## ☆ ヒープ領域のBoF ☆

ヒープ領域に確保したメモリで起きるBoFを起因とした攻撃です。

ヒープ領域においたデータを改竄するものから、ヒープ領域のデータ構造そのものを改竄することでアルゴリズム系(memory allocator)の攻撃につなげることもできます。

### 基礎となる攻撃

- ☆  ユーザーからの入力によるBoF ☆

- ☆ 入力の終端埋めにおけるBoF（Off By One) ☆

- ☆ コピー系の関数を使ったBoF ☆

### 応用した攻撃

- ☆ チャンクサイズの書き換え ☆ 

- ☆ topチャンクの書き換えによる任意アドレスへの動的メモリの割当 ☆

## ☆ malloc() で発動する攻撃 ☆

`malloc()` はサイズ値ひとつを引数に取ります。このサイズ値によって条件次第で攻撃者の意図した動作を起こす攻撃が出来ます。

### 基礎となる攻撃

とくになし

### 応用した攻撃

- ☆ topチャンクの書き換えによる任意アドレスへの動的メモリの割当 ☆

## ☆ free() で発動する攻撃 ☆

`free()` はアドレス値ひとつを引数に取ります。しかし、このアドレス値には `malloc()` や `strdup()` などの `malloc()` 系関数の戻り値によるアドレス以外もとることができます。

これを利用することで偽のメモリ領域の解放をしたり、すでに解放済みのメモリ領域をもう一度解放したりする攻撃ができます。

### 基礎となる攻撃

とくになし

### 応用した攻撃

- ☆ fastbinの二重解放 ☆

## ☆ fastbinの二重解放 ☆

直接 ```main_arena``` につながっている`fast bin`は二重解放しようとするとabortして落ちてしまいます。しかし、`main_arena`に間接的につながっている `fast bin` は二重解放してもabortしません。

これを利用することで、解放後チャンクへ書き込みを行うことが出来るようになります。

### 基礎となる攻撃

- ☆ `free()` で発動する攻撃 ☆

### 応用した攻撃

- ☆ 解放後チャンクの書き換え ☆

## ☆ 解放後チャンクの書き換え ☆

通称 `use after free`

解放後のチャンクには `malloc()` あるいは `free()` をした際にアルゴリズムで定められたデータの構造となるように記録されている情報が置いてあります。

この情報を書き換えることで、攻撃者の意図するデータの構造を作り出す攻撃が可能となります。

### 基礎となる攻撃

- ☆ ヒープ領域のBoF ☆

- ☆ fastbinの二重解放 ☆

### 応用した攻撃

- ☆ fastbinを任意のアドレスにつなげる ☆

## ☆ fastbinを任意のアドレスにつなげる ☆

fastbinのfdを書き換えることで、任意アドレスにfastbinの割り当てられるリンクを貼る攻撃が出来ます。

ただし、fdの直前（`x86`では1ワード前のワード、 `amd64`では1ダブルワード前のダブルワード)が対応するfastbinのサイズになるようにしなければなりません。

### 基礎となる攻撃

- ☆ 解放後チャンクの書き換え ☆

- ☆ `malloc()` で発動する攻撃 ☆

### 応用した攻撃

- ☆ 0x70サイズのfastbinのリンクによる```__{malloc|realloc|memalign}_hook``` に関数の登録（64bit限定） ☆

## ☆ 0x70サイズのfastbinのリンクによる\_\_{malloc|realloc|memalign}\_hook への関数の登録 ☆

### 基礎となる攻撃

- ☆ hookやvtable登録による任意アドレスの呼び出し ☆

### 応用した攻撃

- ☆ one gadgetによるシェルの起動 ☆

## ☆ unsortedbin、smallbinの任意アドレスへのリンク ☆

fd bk を調整することで、任意アドレスへbinを割り当てることが出来る。

満たさなければならない条件は 

- chunkのfd = 任意アドレス として 任意アドレスのbk == chunkのfd

- chunkのbk = 任意アドレス として 任意アドレスのfd == chunkのbk

の両方

## ☆ 偽のunsortedbinの統合によるbinと割当領域の重なり ☆

unsortedbin は

- chunkのfd = 任意アドレス として 任意アドレスのbk == chunkのfd

- chunkのbk = 任意アドレス として 任意アドレスのfd == chunkのbk

- 次の割当領域の ```prev_size``` == チャンクのsize

を満たしていれば、その後にある領域を開放することでいま開放された領域と統合される。

## ☆ topチャンクの改竄によるsysmalloc()の発動 ☆

topチャンクのサイズをいい感じに改竄して、そのサイズ以上のmalloc()をすると大きなunsorted binができる。

## ☆ topチャンクの書き換えによる任意アドレスへの動的メモリの割当 ☆

通称 `House of Force` 

なんかココらへんのバグ

https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#4081

sizeとnbがunsignedではないsize_tだから起こるのかな？

と思ったけど普通にunsigned longだった。

 つまりtopのサイズを0xffffffffffffffff にしておいて、割り当てられる領域のサイズnbを 0x1000000000000000 - (任意のアドレス値）にしておくと 0xffffffffffffffff にしておいて、 0x1000000000000000 - (任意のアドレス値）== - (任意のアドレス値）となり

任意のアドレス値が reminder は top のサイズの入った victim と nb と足し合わされる値になることで

reminder が(任意のアドレス値)になり、それがtopに代入されるという攻撃。

